declare module "all-you-need-by-givi" {
    // Types
    export type HashMap<T> = { [key: string]: T };

    // Arrays
    export function rev<T>(xs: string | T[]): typeof xs;
    export function fold<T>(f: (a: T, b: T) => T, z: T, xs: T[]): T;
    export function foldl<T>(f: (a: T, b: T) => T, z: T, xs: T[]): T;
    export function foldr<T>(f: (a: T, b: T) => T, z: T, xs: T[]): T;
    export function fold1(f: (a: number, b: number) => number, xs: number[]): number;
    export function foldl1(f: (a: number, b: number) => number, xs: number[]): number;
    export function foldr1(f: (a: number, b: number) => number, xs: number[]): number;
    export function fold0(f: (a: number, b: number) => number, xs: number[]): number;
    export function foldl0(f: (a: number, b: number) => number, xs: number[]): number;
    export function foldr0(f: (a: number, b: number) => number, xs: number[]): number;
    export function filter<T>(f: (x: T, i?: number) => boolean, xs: T[]): T[];
    export function reject<T>(f: (x: T, i?: number) => boolean, xs: T[]): T[];
    export function partition<T>(f: (x: T, i?: number) => boolean, xs: T[]): T[][];
    export function map<T, U>(f: (x: T, i?: number) => U, xs: T[]): U[];
    export function freq<T>(k: T, xs: T[]): number;
    export function len<T>(xs: T[]): number;
    export function enumerate<T>(xs: T[]): [number, T][];
    export function member<T>(k: T, xs: T[]): boolean;
    export function mem<T>(k: T, xs: T[]): boolean;
    export function map2<T, N, U>(f: (x: T, y: N) => U, arr1: T[], arr2: N[]): U[];
    export function append<T, U>(xs: T[], ys: U[]): (T | U)[];
    export function listRef<T>(i: number, xs: T[]): T;
    export function hashRef<T>(i: string, hash: HashMap<T>): T;
    export function builtList<T>(f: (x: number) => T, n: number): T[];
    export function sort<T>(xs: T[]): T[];
    export function listTo(x: number, y: number): number[];
    export function listTil(x: number, y: number): number[];
    export function replaceAll<T>(x1: string | T, x2: typeof x1, xs: typeof x1 | (typeof x1)[]): typeof xs;
    export function removeAll<T>(k: string | T, xs: string | T[]): typeof xs;
    export function iter<T>(xs: T[]): IterableIterator<[number, T]>;
    export function indexOf<T>(k: T, xs: T[]): number;
    export function transpose<T>(arr: T[][]): T[][];
    export function chunk<T>(arr: T[]): T[][];
    export function foldstr(f: (a: string, b: string) => string, xs: string | string[]): string;
    export function foldt(f: (a: boolean, b: boolean) => boolean, xs: boolean[]): boolean;
    export function foldf(f: (a: boolean, b: boolean) => boolean, xs: boolean[]): boolean;
    export function listAppend<T, U>(xs: T[], ys: U[]): (T | U)[];
    export function ǀ<T>(xs: T[]): number;
    export function uniq<T>(xs: T[]): T[];
    export function list<T>(...args: T[]): T[];
    export function Ø<T>(xs: T[]): boolean;
    export function ϵ<T>(k: T, xs: T[]): boolean;
    export function ᐡ<T>(xs: T[], ys: T[]): T[];
    export function union<T>(xs: T[], ys: T[]): T[];
    export function ᐢ<T>(xs: T[], ys: T[]): T[];
    export function intersection<T>(xs: T[], ys: T[]): T[];
    export function ᑦ<T>(xs: T[], ys: T[]): boolean;
    export function properSubset<T>(xs: T[], ys: T[]): boolean;
    export function compact<T>(xs: T[]): T[];

    // Conversions
    export function str(s: unknown): string;
    export function int(n: number | string): number;
    export function bool(b: unknown): boolean;
    export function makeHash<T>(xs: [string, T]): HashMap<T>;

    // Function
    export function flip<T, U, N>(f: (a: T, b: U) => N): (b: U, a: T) => N;
    export function noop(x: unknown): void;
    export function id<T>(x: T): T;
    export function before<N>(bf: () => void, f: (...args: unknown[]) => N): (...args: unknown[]) => N;
    export function after<N>(f: (...args: unknown[]) => N, af: () => void): (...args: unknown[]) => N;
    export function throttle(f: (...args: unknown[]) => void): (...args: unknown[]) => void;
    export function debounce(f: (...args: unknown[]) => void, delay: number): (...args: unknown[]) => void;
    export function lazy<N>(f: (...args: unknown[]) => N): (...args: unknown[]) => N;
    export const say: typeof console.log;
    export const p: typeof console.log;
    export function lambda<N>(f: (...args: unknown[]) => N): typeof f;
    export function fn<N>(f: (...args: unknown[]) => N): typeof f;
    export function λ<N>(f: (...args: unknown[]) => N): typeof f;
    export function ƒ<N>(f: (...args: unknown[]) => N): typeof f;
    export function memoize<T, N>(f: (x: T) => N): (x: T) => N;

    // Math
    export function negate(n: number): number;
    export function neg(n: number): number;
    export function ᐨ(n: number): number;
    export function ᕀ(n: number): number;
    export function random(minVal: number, maxVal: number): number;
    export function inc(x: number): number;
    export function dec(x: number): number;
    export function add(a: number, b: number): number;
    export function minus(a: number, b: number): number;
    export function multiply(a: number, b: number): number;
    export function divide(a: number, b: number): number;
    export function equals(a: number | string | boolean, b: typeof a): boolean;
    export function expt(a: number, b: number): number;
    export function pow(a: number, b: number): number;
    export function expm1(a: number): number;
    export function factorial(a: number): number;
    export function ǃ(a: number): number;
    export function comb(n: number, k: number): number;
    export function nCr(n: number, k: number): number;
    export function sin(n: number): number;
    export function cos(n: number): number;
    export function tan(n: number): number;
    export function csc(n: number): number;
    export function sec(n: number): number;
    export function cot(n: number): number;
    export function arcsin(n: number): number;
    export function arccos(n: number): number;
    export function arctan(n: number): number;
    export function arccsc(n: number): number;
    export function arcsec(n: number): number;
    export function arccot(n: number): number;
    export function toRad(n: number): number;
    export function toDeg(n: number): number;
    export function dsin(n: number): number;
    export function dcos(n: number): number;
    export function dtan(n: number): number;
    export function dcsc(n: number): number;
    export function dsec(n: number): number;
    export function dcot(n: number): number;
    export function darcsin(n: number): number;
    export function darccos(n: number): number;
    export function darctan(n: number): number;
    export function darccsc(n: number): number;
    export function darcsec(n: number): number;
    export function darccot(n: number): number;
    export function ln(n: number): number;
    export function recip(n: number): number;
    export function log10(n: number): number;
    export function log1p(n: number): number;
    export function log2(n: number): number;
    export function log(base: number, n: number): number;
    export function even(n: number): boolean;
    export function odd(n: number): boolean;
    export function signum(n: number): number;
    export function E(n: number, ex: number): number;
    export const G: 6.67384e-11;
    export const earthMass: 5.97219e24;
    export const earthRadius: 6378100;
    export const ge: 9.797759126737114;
    export const gn: 9.807;
    export function isNaturalNumber(n: number): boolean;
    export function isInt(n: unknown): boolean;
    export function summation(n: number, i: number, f: (x: number) => number): number;
    export function Σ(xs: number[]): number;
    export function addMatrix(xs: number[][], ys: number[][]): number[][];
    export function minusMatrix(xs: number[][], ys: number[][]): number[][];
    export function multiplyMatrix(xs: number[][], ys: number[][]): number[][];
    export const elementaryCharge: 1.602176634e-19;
    export const e: typeof Math.E;
    export const C: 299792458;
    export const π: typeof Math.PI;
    export const pi: typeof Math.PI;
    export const τ: 6.283185307179586;
    export const tau: 6.283185307179586;
    export const magneticConstant: 0.0000012566370614359173;
    export const μ0: 0.0000012566370614359173;
    export const vacuumPermittivity: 8.854187817620389e-12;
    export const ε0: 8.854187817620389e-12;
    export const Ke: 8987551787.368177;
    export const electronMass: 9.1093837015e-31;
    export const protonMass: 1.67262192e-27;
    export const me: typeof electronMass;
    export const mp: typeof protonMass;
    export const mα: 6.69048768e-27;
    export const alphaParticleMass: typeof mα;
    export const Qα: 3.2043532680000003e-19;
    export const alphaParticleCharge: typeof Qα;
    export function abs(n: number): number;
    export function floor(n: number): number;
    export function ceil(n: number): number;
    export function sqrt(n: number): number;
    export function cbrt(n: number): number;
    export function gcd(n: number, m: number): number;
    export function gcf(n: number, m: number): number;
    export function lcm(n: number, m: number): number;
    export function ǁ(n: number): number;

    // String
    export function lower(s: string): string;
    export function upper(s: string): string;
    export function supertrim(s: string): string;
    export function stringAppend(s1: string, s2: string): string;
    export function charAt(n: number, s: string): string;
    export function title(s: string): string;
    export function isNumeric(s: string): boolean;
    export function trimStart(s: string): string;
    export function trimEnd(s: string): string;
    export function trim(s: string): string;
    export function charcode(n: number): number;
    export function palindrome(s: string): string;

    // Syntax-Replacements
    export function cond<T>(conditions: [boolean | string, unknown | (() => T)][]): unknown | T;
    export function sleep(amount: number, type?: "milliseconds" | "seconds" | "hours" | "days"): void;
    export function pipe<T, U>(x: T, ...fs: Array<(a: unknown) => unknown>): U;

    export class Vec<T> {
        private arr: T[];
        constructor(arr: Vec<T> | T[] | Set<T> | Iterable<T> | ReadonlyArray<T> | string);
        static from<U>(arr: Vec<U> | U[] | Set<U> | Iterable<U> | ReadonlyArray<U> | string): Vec<U>;
        static append<N, M>(xs: Vec<N>, ys: Vec<M>): Vec<N | M>;
        unwrap(): T[];
        clone(): Vec<T>;
        id(): this;
        push(item: T): this;
        len(): number;
        get(i: number): T;
        empty(): boolean;
        clear(): this;
        for_each(f: (el: T, i?: number) => void): void;
        map<U>(f: (el: T, i?: number) => U): Vec<U>;
        filter(f: (el: T, i?: number) => boolean): Vec<T>;
        reject(f: (el: T, i?: number) => boolean): Vec<T>;
        partition(f: (el: T, i?: number) => boolean): Vec<Vec<T>>;
        any(f?: (el: T, i?: number) => boolean): boolean;
        all(f?: (el: T, i?: number) => boolean): boolean;
        flatten<U>(): Vec<U>;
        slice(start?: number, end?: number): Vec<T>;
        take(n: number): Vec<T>;
        drop(n: number): Vec<T>;
        rev(): Vec<T>;
        concat<N>(vec: Vec<N>): Vec<T | N>;
        uniq(): Vec<T>;
        chunk(size: number): Vec<Vec<T>>;
        find(pre: (el: T, i?: number) => boolean): T | undefined;
        index_of(el: T): number;
        last_index_of(el: T): number;
        to_s(): string;
        shuffle(): Vec<T>;
        fold1(f: (z: number, x: number) => number): number;
        fold(f: (z: T, x: T) => T, z: T): T;
        foldl(f: (z: T, x: T) => T, z: T): T;
        foldr(f: (z: T, x: T) => T, z: T): T;
        foldr1(f: (z: number, x: number) => number): number;
        foldr0(f: (z: number, x: number) => number): number;
        foldl0(f: (z: number, x: number) => number): number;
        foldl1(f: (z: number, x: number) => number): number;
        fold0(f: (z: number, x: number) => number): number;
        first(): T | undefined;
        last(): T | undefined;
        freq(f: Parameters<typeof this.filter>[0]): number;
        freq_of(k: T): number;
        map2<U, N>(f: (x: T, y: N) => U, arr: Vec<N> | N[] | Set<N>): Vec<U>;
        compact(): Vec<T>;
        sum(): number;
        avg(): number;
        product(): number;
        mem(k: T): boolean;
        iter(): IterableIterator<[number, T]>;
        rem(k: T): this;
        sort_by(f: (x: T, y: T) => number): Vec<T>;
        to_set(): Set<T>;
        Ø(): true | false;
        difference<N>(arr: ConstructorParameters<typeof Vec<N>>[0]): Vec<N | T>;
        Δ<N>(arr: ConstructorParameters<typeof Vec<N>>[0]): Vec<N | T>;
        intersection<N>(arr: ConstructorParameters<typeof Vec<N>>[0]): Vec<N | T>;
        ᐢ<N>(arr: ConstructorParameters<typeof Vec<N>>[0]): Vec<N | T>;
        ϵ(x: T): boolean;
        union<N>(arr: ConstructorParameters<typeof Vec<N>>[0]): Vec<N | T>;
        ᐡ<N>(arr: ConstructorParameters<typeof Vec<N>>[0]): Vec<N | T>;
        properSubset<N>(arr: ConstructorParameters<typeof Vec<N>>[0]): boolean;
        ᑦ<N>(arr: ConstructorParameters<typeof Vec<N>>[0]): boolean;
        ᑦR(): boolean;
        ᑦN(): boolean;
    }
}
